<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithms and Data Structures</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            line-height: 1.6;
        }
        h1, h2 {
            color: #2c3e50;
        }
        h3 {
            color: #34495e;
        }
        p, li {
            font-size: 16px;
        }
        pre {
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
        .algorithm-title {
            font-weight: bold;
            color: #2980b9;
        }
    </style>
</head>
<body>
    <h1>Algorithms and Data Structures</h1>

    <h2>Space and Time Efficiency</h2>
    <p><strong>Importance of Analyzing Algorithmic Complexity</strong></p>
    <p>Analyzing algorithm complexity ensures scalability and efficient handling of larger data. For example, bubble sort has <span class="algorithm-title">O(n&sup2;)</span>, while merge sort has <span class="algorithm-title">O(n log n)</span>.</p>

    <h3>Orders of Growth</h3>
    <ul>
        <li><strong>O(1)</strong>: Constant time (e.g., array access)</li>
        <li><strong>O(log n)</strong>: Logarithmic time (e.g., binary search)</li>
        <li><strong>O(n)</strong>: Linear time (e.g., iterating through an array)</li>
        <li><strong>O(n&sup2;)</strong>: Quadratic time (e.g., bubble sort)</li>
    </ul>

    <h2>Sorting and Searching</h2>

    <h3>Sorting Algorithms</h3>

    <p><strong>Bubble Sort:</strong></p>
    <pre class="algorithm-title">
ALGORITHM BubbleSort(A[0..n-1])
    for i <- 0 to n - 2 do
        for j <- 0 to n - 2 - i do
            if A[j+1] < A[j]
                swap A[j] and A[j+1]
    </pre>

    <p><strong>Insertion Sort:</strong></p>
    <p>Description: Builds the final sorted list one item at a time. It takes each element from the list and inserts it into its correct position.</p>
    <p>Time Complexity: O(n&sup2;) in the average and worst case, but O(n) in the best case.</p>
    <pre class="algorithm-title">
void insertionSort(vector<int>& A) {
    int n = A.size();
    for (int i = 1; i < n; i++) {
        int key = A[i];
        int j = i - 1;
        while (j >= 0 && A[j] > key) {
            A[j + 1] = A[j];
            j = j - 1;
        }
        A[j + 1] = key;
    }
}
    </pre>

    <p><strong>Selection Sort:</strong></p>
    <p>Description: Repeatedly finds the minimum element from the unsorted part of the list and moves it to the sorted part.</p>
    <p>Time Complexity: O(n&sup2;) in the average and worst case.</p>
    <pre class="algorithm-title">
void selectionSort(vector<int>& A) {
    int n = A.size();
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < n; j++) {
            if (A[j] < A[minIndex]) {
                minIndex = j;
            }
        }
        swap(A[i], A[minIndex]);
    }
}
    </pre>

    <p><strong>Heap Sort:</strong></p>
    <p>Description: Converts the list into a heap data structure, then repeatedly extracts the maximum element (for max-heap) or minimum element (for min-heap) and rebuilds the heap until the list is sorted.</p>
    <p>Time Complexity: O(n log n) in the average, worst, and best case.</p>
    <pre class="algorithm-title">
void heapify(vector<int>& A, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < n && A[left] > A[largest])
        largest = left;

    if (right < n && A[right] > A[largest])
        largest = right;

    if (largest != i) {
        swap(A[i], A[largest]);
        heapify(A, n, largest);
    }
}

void heapSort(vector<int>& A) {
    int n = A.size();

    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(A, n, i);

    for (int i = n - 1; i > 0; i--) {
        swap(A[0], A[i]);
        heapify(A, i, 0);
    }
}
    </pre>

    <h3>Binary Search Tree (BST)</h3>
    <p>A Binary Search Tree (BST) is a type of binary tree that maintains a sorted order of elements, which makes searching, insertion, and deletion operations efficient.</p>

    <h4>Structure:</h4>
    <ul>
        <li><strong>Data:</strong> The value stored in the node.</li>
        <li><strong>Left Child:</strong> A pointer to the left subtree, which contains nodes with values less than the node's data.</li>
        <li><strong>Right Child:</strong> A pointer to the right subtree, which contains nodes with values greater than the node's data.</li>
    </ul>

    <h4>Properties:</h4>
    <ul>
        <li><strong>Binary Property:</strong> Each node has at most two children.</li>
        <li><strong>Search Property:</strong> For any given node, all elements in the left subtree are less than the node's value, and all elements in the right subtree are greater than the node's value.</li>
        <li>This property ensures that an in-order traversal (left, root, right) of the tree results in a sorted sequence of values.</li>
    </ul>

    <h4>Operations:</h4>
    <p><strong>Search:</strong> To find a value, start at the root and recursively traverse the left or right child depending on whether the value is less than or greater than the current node's value.</p>

    <p><strong>Insertion:</strong> To insert a new value, start at the root and recursively traverse the left or right child until finding an appropriate spot where the new node can be added.</p>

    <p><strong>Deletion:</strong> Deleting a node requires considering three cases:</p>
    <ul>
        <li>Node with no children (leaf node): Simply remove the node.</li>
        <li>Node with one child: Remove the node and replace it with its child.</li>
        <li>Node with two children: Find the in-order predecessor (maximum value in the left subtree) or in-order successor (minimum value in the right subtree) to replace the node, and then delete the predecessor or successor.</li>
    </ul>

    <p><strong>Time Complexity:</strong></p>
    <ul>
        <li>Average Case: O(log n) for search, insertion, and deletion, assuming the tree is balanced.</li>
        <li>Worst Case: O(n) for search, insertion, and deletion, when the tree becomes a degenerate (unbalanced) tree resembling a linked list.</li>
    </ul>

    <pre class="algorithm-title">
struct Node {
    int data;
    Node* left;
    Node* right;
    Node(int val) : data(val), left(nullptr), right(nullptr) {}
};

Node* insert(Node* root, int key) {
    if (root == nullptr) return new Node(key);
    if (key < root->data)
        root->left = insert(root->left, key);
    else if (key > root->data)
        root->right = insert(root->right, key);
    return root;
}

Node* search(Node* root, int key) {
    if (root == nullptr || root->data == key)
        return root;
    if (key < root->data)
        return search(root->left, key);
    return search(root->right, key);
}

Node* minValueNode(Node* node) {
    Node* current = node;
    while (current && current->left != nullptr)
        current = current->left;
    return current;
}

Node* deleteNode(Node* root, int key) {
    if (root == nullptr) return root;

    if (key < root->data)
        root->left = deleteNode(root->left, key);
    else if (key > root->data)
        root->right = deleteNode(root->right, key);
    else {
        if (root->left == nullptr) {
            Node* temp = root->right;
            delete root;
            return temp;
        } else if (root->right == nullptr) {
            Node* temp = root->left;
            delete root;
            return temp;
        }

        Node* temp = minValueNode(root->right);
        root->data = temp->data;
        root->right = deleteNode(root->right, temp->data);
    }
    return root;
}
    </pre>

    <a href="index.html">Back to Portfolio</a>

</body>
</html>










